---
title: no-unnecessary-use-ref
---

<Callout type="warning">This rule is experimental and may change in the future or be removed. It is not recommended for use in production code at this time.</Callout>

**Full Name in `@eslint-react/eslint-plugin`**

```plain copy
@eslint-react/no-unnecessary-use-ref
```

**Full Name in `eslint-plugin-react-x`**

```plain copy
react-x/no-unnecessary-use-ref
```

**Features**

`ðŸ§ª`

**Presets**

`strict`
`strict-typescript`
`strict-type-checked`

## Description

Disallows unnecessary usage of `useRef`.

If a ref holds a value that is only used inside a single effect, it is unnecessary to use `useRef`. Instead, co-locate the value inside the effect that uses it.

## Examples

### Failing

```tsx
import React, { useEffect, useRef } from "react";

function MyComponent() {
  const ref = useRef<number | null>(null);
  //    ðŸŸ¡ Unnecessary use of `useRef`. Instead, co-locate the value inside the effect that uses it.

  useEffect(() => {
    ref.current = requestAnimationFrame(() => {});
    return () => {
      if (ref.current != null) {
        cancelAnimationFrame(ref.current);
      }
    };
  }, []);
}
```

```tsx
import React, { useLayoutEffect, useRef } from "react";

function MyComponent() {
  const ref = useRef<HTMLInputElement | null>(null);
  //    ðŸŸ¡ Unnecessary use of `useRef`. Instead, co-locate the value inside the effect that uses it.

  useLayoutEffect(() => {
    if (ref.current) {
      ref.current.focus();
    }
    return () => {
      if (ref.current) {
        ref.current.blur();
      }
    };
  }, []);
}
```

### Passing

```tsx
import React, { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    let ref: number | null = requestAnimationFrame(() => {});
    //  ðŸŸ¢ Using a local variable to co-locate the value inside the effect that uses it.
    return () => {
      if (ref != null) {
        cancelAnimationFrame(ref);
      }
    };
  }, []);
}
```

```tsx
import React, { useEffect, useRef } from "react";

// Valid because the ref is used across more than one effect.
function MyComponent() {
  const ref = useRef<number | null>(null);

  useEffect(() => {
    ref.current = setTimeout(() => {}, 100);
  }, []);

  useEffect(() => {
    if (ref.current != null) {
      clearTimeout(ref.current);
    }
  }, []);
}
```

```tsx
import React, { useRef } from "react";

function MyComponent() {
  // Unused refs are considered valid because other rules like `no-unused-vars` can catch them.
  const ref = useRef<number | null>(null);

  // ...
}
```

## Implementation

- [Rule Source](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x/src/rules/no-unnecessary-use-ref.ts)
- [Test Source](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x/src/rules/no-unnecessary-use-ref.spec.ts)

---

## See Also

- [`no-unnecessary-use-callback`](./no-unnecessary-use-callback)\
  Disallows unnecessary usage of `useCallback`.
- [`no-unnecessary-use-memo`](./no-unnecessary-use-memo)\
  Disallows unnecessary usage of `useMemo`.
