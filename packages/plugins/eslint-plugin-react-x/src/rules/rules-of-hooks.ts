// @ts-nocheck
// -----------------------------------------------------------------------------
// THIS FILE IS PORTED FROM eslint-plugin-react-hooks
// Source: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts
// DO NOT EDIT THIS FILE MANUALLY.
// Changes to the rule logic should be made upstream and re-ported.
// Local adaptations:
//   - `getAdditionalEffectHooksFromSettings` replaced by `getSettingsFromContext`
//     from `@eslint-react/shared`, reading `additionalEffectHooks` from
//     the `react-x` settings namespace.
//
// Copyright (c) Meta Platforms, Inc. and affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
// -----------------------------------------------------------------------------

import { type RuleFeature, getSettingsFromContext } from "@eslint-react/shared";
import type { TSESTree } from "@typescript-eslint/types";
import type { Rule, Scope } from "eslint";

type CallExpression = TSESTree.CallExpression;
type CatchClause = TSESTree.CatchClause;
type DoWhileStatement = TSESTree.DoWhileStatement;
type Expression = TSESTree.Expression;
type Identifier = TSESTree.Identifier;
type Node = TSESTree.Node;
type Super = TSESTree.Super;
type TryStatement = TSESTree.TryStatement;

export const RULE_NAME = "rules-of-hooks";

export const RULE_FEATURES = [
  "CFG",
  "FIX",
] as const satisfies RuleFeature[];

/**
 * Catch all identifiers that begin with "use" followed by an uppercase Latin
 * character to exclude identifiers like "user".
 */
function isHookName(s: string): boolean {
  return s === "use" || /^use[A-Z0-9]/.test(s);
}

/**
 * We consider hooks to be a hook name identifier or a member expression
 * containing a hook name.
 */
function isHook(node: Node): boolean {
  if (node.type === "Identifier") {
    return isHookName(node.name);
  } else if (
    node.type === "MemberExpression"
    && !node.computed
    && isHook(node.property)
  ) {
    const obj = node.object;
    const isPascalCaseNameSpace = /^[A-Z].*/;
    return obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name);
  } else {
    return false;
  }
}

/**
 * Checks if the node is a React component name. React component names must
 * always start with an uppercase letter.
 */
function isComponentName(node: Node): boolean {
  return node.type === "Identifier" && /^[A-Z]/.test(node.name);
}

function isReactFunction(node: Node, functionName: string): boolean {
  return (
    ("name" in node && node.name === functionName)
    || (node.type === "MemberExpression"
      && "name" in node.object
      && node.object.name === "React"
      && "name" in node.property
      && node.property.name === functionName)
  );
}

/**
 * Checks if the node is a callback argument of forwardRef. This render function
 * should follow the rules of hooks.
 */
function isForwardRefCallback(node: Node): boolean {
  return !!(
    node.parent
    && "callee" in node.parent
    && node.parent.callee
    && isReactFunction(node.parent.callee, "forwardRef")
  );
}

/**
 * Checks if the node is a callback argument of React.memo. This anonymous
 * functional component should follow the rules of hooks.
 */
function isMemoCallback(node: Node): boolean {
  return !!(
    node.parent
    && "callee" in node.parent
    && node.parent.callee
    && isReactFunction(node.parent.callee, "memo")
  );
}

function isInsideComponentOrHook(node: Node | undefined): boolean {
  while (node) {
    const functionName = getFunctionName(node);
    if (functionName) {
      if (isComponentName(functionName) || isHook(functionName)) {
        return true;
      }
    }
    if (isForwardRefCallback(node) || isMemoCallback(node)) {
      return true;
    }
    node = node.parent;
  }
  return false;
}

function isInsideDoWhileLoop(node: Node | undefined): node is DoWhileStatement {
  while (node) {
    if (node.type === "DoWhileStatement") {
      return true;
    }
    node = node.parent;
  }
  return false;
}

function isInsideTryCatch(
  node: Node | undefined,
): node is TryStatement | CatchClause {
  while (node) {
    if (node.type === "TryStatement" || node.type === "CatchClause") {
      return true;
    }
    node = node.parent;
  }
  return false;
}

function getNodeWithoutReactNamespace(
  node: Expression | Super,
): Expression | Identifier | Super {
  if (
    node.type === "MemberExpression"
    && node.object.type === "Identifier"
    && node.object.name === "React"
    && node.property.type === "Identifier"
    && !node.computed
  ) {
    return node.property;
  }
  return node;
}

function isEffectIdentifier(node: Node, additionalHooks?: RegExp): boolean {
  const isBuiltInEffect = node.type === "Identifier"
    && (node.name === "useEffect"
      || node.name === "useLayoutEffect"
      || node.name === "useInsertionEffect");

  if (isBuiltInEffect) {
    return true;
  }

  // Check if this matches additional hooks configured by the user
  if (additionalHooks && node.type === "Identifier") {
    return additionalHooks.test(node.name);
  }

  return false;
}

function isUseEffectEventIdentifier(node: Node): boolean {
  return node.type === "Identifier" && node.name === "useEffectEvent";
}

function useEffectEventError(fn: string | null, called: boolean): string {
  // no function identifier, i.e. it is not assigned to a variable
  if (fn === null) {
    return (
      `React Hook "useEffectEvent" can only be called at the top level of your component.`
      + ` It cannot be passed down.`
    );
  }

  return (
    `\`${fn}\` is a function created with React Hook "useEffectEvent", and can only be called from `
    + "Effects and Effect Events in the same component."
    + (called ? "" : " It cannot be assigned to a variable or passed down.")
  );
}

function isUseIdentifier(node: Node): boolean {
  return isReactFunction(node, "use");
}

const rule = {
  meta: {
    type: "problem",
    docs: {
      description: "Enforces the Rules of Hooks.",
      recommended: true,
      url: "https://react.dev/reference/rules/rules-of-hooks",
    },
    schema: [
      {
        type: "object",
        additionalProperties: false,
        properties: {
          additionalHooks: {
            type: "string",
          },
        },
      },
    ],
  },
  create(context: Rule.RuleContext) {
    const settings = context.settings || {};
    const rawOptions = context.options && context.options[0];

    // Parse the `additionalHooks` regex.
    // Use rule-level additionalHooks if provided, otherwise fall back to settings
    const additionalEffectHooks = rawOptions && rawOptions.additionalHooks
      ? new RegExp(rawOptions.additionalHooks)
      : getSettingsFromContext(context).additionalEffectHooks;

    let lastEffect: CallExpression | null = null;
    const codePathReactHooksMapStack: Array<
      Map<Rule.CodePathSegment, Array<Node>>
    > = [];
    const codePathSegmentStack: Array<Rule.CodePathSegment> = [];
    const useEffectEventFunctions = new WeakSet();

    // For a given scope, iterate through the references and add all useEffectEvent definitions. We can
    // do this in non-Program nodes because we can rely on the assumption that useEffectEvent functions
    // can only be declared within a component or hook at its top level.
    function recordAllUseEffectEventFunctions(scope: Scope.Scope): void {
      for (const reference of scope.references) {
        const parent = reference.identifier.parent;
        if (
          parent?.type === "VariableDeclarator"
          && parent.init
          && parent.init.type === "CallExpression"
          && parent.init.callee
          && isUseEffectEventIdentifier(parent.init.callee)
        ) {
          if (reference.resolved === null) {
            throw new Error("Unexpected null reference.resolved");
          }
          for (const ref of reference.resolved.references) {
            if (ref !== reference) {
              useEffectEventFunctions.add(ref.identifier);
            }
          }
        }
      }
    }

    /**
     * SourceCode that also works down to ESLint 3.0.0
     */
    const getSourceCode = typeof context.getSourceCode === "function"
      ? () => {
        return context.getSourceCode();
      }
      : () => {
        return context.sourceCode;
      };
    /**
     * SourceCode#getScope that also works down to ESLint 3.0.0
     */
    const getScope = typeof context.getScope === "function"
      ? (): Scope.Scope => {
        return context.getScope();
      }
      : (node: Node): Scope.Scope => {
        return getSourceCode().getScope(node);
      };

    function hasFlowSuppression(node: Node, suppression: string) {
      const sourceCode = getSourceCode();
      const comments = sourceCode.getAllComments();
      const flowSuppressionRegex = new RegExp(
        "\\$FlowFixMe\\[" + suppression + "\\]",
      );
      return comments.some(
        commentNode =>
          flowSuppressionRegex.test(commentNode.value)
          && commentNode.loc != null
          && node.loc != null
          && commentNode.loc.end.line === node.loc.start.line - 1,
      );
    }

    const analyzer = new CodePathAnalyzer({
      // Maintain code segment path stack as we traverse.
      onCodePathSegmentStart: (segment: Rule.CodePathSegment) => codePathSegmentStack.push(segment),
      onCodePathSegmentEnd: () => codePathSegmentStack.pop(),

      // Maintain code path stack as we traverse.
      onCodePathStart: () =>
        codePathReactHooksMapStack.push(
          new Map<Rule.CodePathSegment, Array<Node>>(),
        ),

      // Process our code path.
      //
      // Everything is ok if all React Hooks are both reachable from the initial
      // segment and reachable from every final segment.
      onCodePathEnd(codePath: any, codePathNode: Node) {
        const reactHooksMap = codePathReactHooksMapStack.pop();
        if (reactHooksMap?.size === 0) {
          return;
        } else if (typeof reactHooksMap === "undefined") {
          throw new Error("Unexpected undefined reactHooksMap");
        }

        // All of the segments which are cyclic are recorded in this set.
        const cyclic = new Set();

        /**
         * Count the number of code paths from the start of the function to this
         * segment. For example:
         *
         * ```js
         * function MyComponent() {
         *   if (condition) {
         *     // Segment 1
         *   } else {
         *     // Segment 2
         *   }
         *   // Segment 3
         * }
         * ```
         *
         * Segments 1 and 2 have one path to the beginning of `MyComponent` and
         * segment 3 has two paths to the beginning of `MyComponent` since we
         * could have either taken the path of segment 1 or segment 2.
         *
         * Populates `cyclic` with cyclic segments.
         */
        function countPathsFromStart(
          segment: Rule.CodePathSegment,
          pathHistory?: Set<string>,
        ): bigint {
          const { cache } = countPathsFromStart;
          let paths = cache.get(segment.id);
          const pathList = new Set<string>(pathHistory);

          // If `pathList` includes the current segment then we've found a cycle!
          // We need to fill `cyclic` with all segments inside cycle
          if (pathList.has(segment.id)) {
            const pathArray = [...pathList];
            const cyclicSegments = pathArray.slice(
              pathArray.indexOf(segment.id) + 1,
            );
            for (const cyclicSegment of cyclicSegments) {
              cyclic.add(cyclicSegment);
            }

            return BigInt("0");
          }

          // add the current segment to pathList
          pathList.add(segment.id);

          // We have a cached `paths`. Return it.
          if (paths !== undefined) {
            return paths;
          }

          if (codePath.thrownSegments.includes(segment)) {
            paths = BigInt("0");
          } else if (segment.prevSegments.length === 0) {
            paths = BigInt("1");
          } else {
            paths = BigInt("0");
            for (const prevSegment of segment.prevSegments) {
              paths += countPathsFromStart(prevSegment, pathList);
            }
          }

          // If our segment is reachable then there should be at least one path
          // to it from the start of our code path.
          if (segment.reachable && paths === BigInt("0")) {
            cache.delete(segment.id);
          } else {
            cache.set(segment.id, paths);
          }

          return paths;
        }

        /**
         * Count the number of code paths from this segment to the end of the
         * function. For example:
         *
         * ```js
         * function MyComponent() {
         *   // Segment 1
         *   if (condition) {
         *     // Segment 2
         *   } else {
         *     // Segment 3
         *   }
         * }
         * ```
         *
         * Segments 2 and 3 have one path to the end of `MyComponent` and
         * segment 1 has two paths to the end of `MyComponent` since we could
         * either take the path of segment 1 or segment 2.
         *
         * Populates `cyclic` with cyclic segments.
         */

        function countPathsToEnd(
          segment: Rule.CodePathSegment,
          pathHistory?: Set<string>,
        ): bigint {
          const { cache } = countPathsToEnd;
          let paths = cache.get(segment.id);
          const pathList = new Set(pathHistory);

          // If `pathList` includes the current segment then we've found a cycle!
          // We need to fill `cyclic` with all segments inside cycle
          if (pathList.has(segment.id)) {
            const pathArray = Array.from(pathList);
            const cyclicSegments = pathArray.slice(
              pathArray.indexOf(segment.id) + 1,
            );
            for (const cyclicSegment of cyclicSegments) {
              cyclic.add(cyclicSegment);
            }

            return BigInt("0");
          }

          // add the current segment to pathList
          pathList.add(segment.id);

          // We have a cached `paths`. Return it.
          if (paths !== undefined) {
            return paths;
          }

          if (codePath.thrownSegments.includes(segment)) {
            paths = BigInt("0");
          } else if (segment.nextSegments.length === 0) {
            paths = BigInt("1");
          } else {
            paths = BigInt("0");
            for (const nextSegment of segment.nextSegments) {
              paths += countPathsToEnd(nextSegment, pathList);
            }
          }

          cache.set(segment.id, paths);
          return paths;
        }

        /**
         * Gets the shortest path length to the start of a code path.
         * For example:
         *
         * ```js
         * function MyComponent() {
         *   if (condition) {
         *     // Segment 1
         *   }
         *   // Segment 2
         * }
         * ```
         *
         * There is only one path from segment 1 to the code path start. Its
         * length is one so that is the shortest path.
         *
         * There are two paths from segment 2 to the code path start. One
         * through segment 1 with a length of two and another directly to the
         * start with a length of one. The shortest path has a length of one
         * so we would return that.
         */

        function shortestPathLengthToStart(
          segment: Rule.CodePathSegment,
        ): number {
          const { cache } = shortestPathLengthToStart;
          let length = cache.get(segment.id);

          // If `length` is null then we found a cycle! Return infinity since
          // the shortest path is definitely not the one where we looped.
          if (length === null) {
            return Infinity;
          }

          // We have a cached `length`. Return it.
          if (length !== undefined) {
            return length;
          }

          // Compute `length` and cache it. Guarding against cycles.
          cache.set(segment.id, null);
          if (segment.prevSegments.length === 0) {
            length = 1;
          } else {
            length = Infinity;
            for (const prevSegment of segment.prevSegments) {
              const prevLength = shortestPathLengthToStart(prevSegment);
              if (prevLength < length) {
                length = prevLength;
              }
            }
            length += 1;
          }
          cache.set(segment.id, length);
          return length;
        }

        countPathsFromStart.cache = new Map<string, bigint>();
        countPathsToEnd.cache = new Map<string, bigint>();
        shortestPathLengthToStart.cache = new Map<string, number | null>();

        // Count all code paths to the end of our component/hook. Also primes
        // the `countPathsToEnd` cache.
        const allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment);

        // Gets the function name for our code path. If the function name is
        // `undefined` then we know either that we have an anonymous function
        // expression or our code path is not in a function. In both cases we
        // will want to error since neither are React function components or
        // hook functions - unless it is an anonymous function argument to
        // forwardRef or memo.
        const codePathFunctionName = getFunctionName(codePathNode);

        // This is a valid code path for React hooks if we are directly in a React
        // function component or we are in a hook function.
        const isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);
        const isDirectlyInsideComponentOrHook = codePathFunctionName
          ? isComponentName(codePathFunctionName)
            || isHook(codePathFunctionName)
          : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode);

        // Compute the earliest finalizer level using information from the
        // cache. We expect all reachable final segments to have a cache entry
        // after calling `visitSegment()`.
        let shortestFinalPathLength = Infinity;
        for (const finalSegment of codePath.finalSegments) {
          if (!finalSegment.reachable) {
            continue;
          }
          const length = shortestPathLengthToStart(finalSegment);
          if (length < shortestFinalPathLength) {
            shortestFinalPathLength = length;
          }
        }

        // Make sure all React Hooks pass our lint invariants. Log warnings
        // if not.
        for (const [segment, reactHooks] of reactHooksMap) {
          // NOTE: We could report here that the hook is not reachable, but
          // that would be redundant with more general "no unreachable"
          // lint rules.
          if (!segment.reachable) {
            continue;
          }

          // If there are any final segments with a shorter path to start then
          // we possibly have an early return.
          //
          // If our segment is a final segment itself then siblings could
          // possibly be early returns.
          const possiblyHasEarlyReturn = segment.nextSegments.length === 0
            ? shortestFinalPathLength <= shortestPathLengthToStart(segment)
            : shortestFinalPathLength < shortestPathLengthToStart(segment);

          // Count all the paths from the start of our code path to the end of
          // our code path that go _through_ this segment. The critical piece
          // of this is _through_. If we just call `countPathsToEnd(segment)`
          // then we neglect that we may have gone through multiple paths to get
          // to this point! Consider:
          //
          // ```js
          // function MyComponent() {
          //   if (a) {
          //     // Segment 1
          //   } else {
          //     // Segment 2
          //   }
          //   // Segment 3
          //   if (b) {
          //     // Segment 4
          //   } else {
          //     // Segment 5
          //   }
          // }
          // ```
          //
          // In this component we have four code paths:
          //
          // 1. `a = true; b = true`
          // 2. `a = true; b = false`
          // 3. `a = false; b = true`
          // 4. `a = false; b = false`
          //
          // From segment 3 there are two code paths to the end through segment
          // 4 and segment 5. However, we took two paths to get here through
          // segment 1 and segment 2.
          //
          // If we multiply the paths from start (two) by the paths to end (two)
          // for segment 3 we get four. Which is our desired count.
          const pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment);

          // Is this hook a part of a cyclic segment?
          const cycled = cyclic.has(segment.id);

          for (const hook of reactHooks) {
            // Skip reporting if this hook already has a relevant flow suppression.
            if (hasFlowSuppression(hook, "react-rule-hook")) {
              continue;
            }

            // Report an error if use() is called inside try/catch.
            if (isUseIdentifier(hook) && isInsideTryCatch(hook)) {
              context.report({
                node: hook,
                message: `React Hook "${
                  getSourceCode().getText(
                    hook,
                  )
                }" cannot be called in a try/catch block.`,
              });
            }

            // Report an error if a hook may be called more then once.
            // `use(...)` can be called in loops.
            if (
              (cycled || isInsideDoWhileLoop(hook))
              && !isUseIdentifier(hook)
            ) {
              context.report({
                node: hook,
                message: `React Hook "${
                  getSourceCode().getText(
                    hook,
                  )
                }" may be executed `
                  + "more than once. Possibly because it is called in a loop. "
                  + "React Hooks must be called in the exact same order in "
                  + "every component render.",
              });
            }

            // If this is not a valid code path for React hooks then we need to
            // log a warning for every hook in this code path.
            //
            // Pick a special message depending on the scope this hook was
            // called in.
            if (isDirectlyInsideComponentOrHook) {
              // Report an error if the hook is called inside an async function.
              // @ts-expect-error the above check hasn't properly type-narrowed `codePathNode` (async doesn't exist on Node)
              const isAsyncFunction = codePathNode.async;
              if (isAsyncFunction) {
                context.report({
                  node: hook,
                  message: `React Hook "${getSourceCode().getText(hook)}" cannot be `
                    + "called in an async function.",
                });
              }

              // Report an error if a hook does not reach all finalizing code
              // path segments.
              //
              // Special case when we think there might be an early return.
              if (
                !cycled
                && pathsFromStartToEnd !== allPathsFromStartToEnd
                && !isUseIdentifier(hook) // `use(...)` can be called conditionally.
                && !isInsideDoWhileLoop(hook) // wrapping do/while loops are checked separately.
              ) {
                const message = `React Hook "${getSourceCode().getText(hook)}" is called `
                  + "conditionally. React Hooks must be called in the exact "
                  + "same order in every component render."
                  + (possiblyHasEarlyReturn
                    ? " Did you accidentally call a React Hook after an"
                      + " early return?"
                    : "");
                context.report({ node: hook, message });
              }
            } else if (
              codePathNode.parent != null
              && (codePathNode.parent.type === "MethodDefinition"
                // @ts-expect-error `ClassProperty` was removed from typescript-estree in https://github.com/typescript-eslint/typescript-eslint/pull/3806
                || codePathNode.parent.type === "ClassProperty"
                || codePathNode.parent.type === "PropertyDefinition")
              && codePathNode.parent.value === codePathNode
            ) {
              // Custom message for hooks inside a class
              const message = `React Hook "${
                getSourceCode().getText(
                  hook,
                )
              }" cannot be called `
                + "in a class component. React Hooks must be called in a "
                + "React function component or a custom React Hook function.";
              context.report({ node: hook, message });
            } else if (codePathFunctionName) {
              // Custom message if we found an invalid function name.
              const message = `React Hook "${getSourceCode().getText(hook)}" is called in `
                + `function "${getSourceCode().getText(codePathFunctionName)}" `
                + "that is neither a React function component nor a custom "
                + "React Hook function."
                + " React component names must start with an uppercase letter."
                + ' React Hook names must start with the word "use".';
              context.report({ node: hook, message });
            } else if (codePathNode.type === "Program") {
              // These are dangerous if you have inline requires enabled.
              const message = `React Hook "${
                getSourceCode().getText(
                  hook,
                )
              }" cannot be called `
                + "at the top level. React Hooks must be called in a "
                + "React function component or a custom React Hook function.";
              context.report({ node: hook, message });
            } else {
              // Assume in all other cases the user called a hook in some
              // random function callback. This should usually be true for
              // anonymous function expressions. Hopefully this is clarifying
              // enough in the common case that the incorrect message in
              // uncommon cases doesn't matter.
              // `use(...)` can be called in callbacks.
              if (isSomewhereInsideComponentOrHook && !isUseIdentifier(hook)) {
                const message = `React Hook "${
                  getSourceCode().getText(
                    hook,
                  )
                }" cannot be called `
                  + "inside a callback. React Hooks must be called in a "
                  + "React function component or a custom React Hook function.";
                context.report({ node: hook, message });
              }
            }
          }
        }
      },
    });

    return {
      "*"(node: any) {
        analyzer.enterNode(node);
      },

      "*:exit"(node: any) {
        analyzer.leaveNode(node);
      },

      // Missed opportunity...We could visit all `Identifier`s instead of all
      // `CallExpression`s and check that _every use_ of a hook name is valid.
      // But that gets complicated and enters type-system territory, so we're
      // only being strict about hook calls for now.
      CallExpression(node) {
        if (isHook(node.callee)) {
          // Add the hook node to a map keyed by the code path segment. We will
          // do full code path analysis at the end of our code path.
          const reactHooksMap = last(codePathReactHooksMapStack);
          const codePathSegment = last(codePathSegmentStack);
          let reactHooks = reactHooksMap.get(codePathSegment);
          if (!reactHooks) {
            reactHooks = [];
            reactHooksMap.set(codePathSegment, reactHooks);
          }
          reactHooks.push(node.callee);
        }

        // useEffectEvent: useEffectEvent functions can be passed by reference within useEffect as well as in
        // another useEffectEvent
        // Check all `useEffect` and `React.useEffect`, `useEffectEvent`, and `React.useEffectEvent`
        const nodeWithoutNamespace = getNodeWithoutReactNamespace(node.callee);
        if (
          (isEffectIdentifier(nodeWithoutNamespace, additionalEffectHooks)
            || isUseEffectEventIdentifier(nodeWithoutNamespace))
          && node.arguments.length > 0
        ) {
          // Denote that we have traversed into a useEffect call, and stash the CallExpr for
          // comparison later when we exit
          lastEffect = node;
        }

        // Specifically disallow <Child onClick={useEffectEvent(...)} /> because this
        // case can't be caught by `recordAllUseEffectEventFunctions` as it isn't assigned to a variable
        if (
          isUseEffectEventIdentifier(nodeWithoutNamespace)
          && node.parent?.type !== "VariableDeclarator"
          // like in other hooks, calling useEffectEvent at component's top level without assignment is valid
          && node.parent?.type !== "ExpressionStatement"
        ) {
          const message = useEffectEventError(null, false);

          context.report({
            node,
            message,
          });
        }
      },

      Identifier(node) {
        // This identifier resolves to a useEffectEvent function, but isn't being referenced in an
        // effect or another event function. It isn't being called either.
        if (lastEffect == null && useEffectEventFunctions.has(node)) {
          const message = useEffectEventError(
            getSourceCode().getText(node),
            node.parent.type === "CallExpression",
          );

          context.report({
            node,
            message,
          });
        }
      },

      "CallExpression:exit"(node) {
        if (node === lastEffect) {
          lastEffect = null;
        }
      },

      FunctionDeclaration(node) {
        // function MyComponent() { const onClick = useEffectEvent(...) }
        if (isInsideComponentOrHook(node)) {
          recordAllUseEffectEventFunctions(getScope(node));
        }
      },

      ArrowFunctionExpression(node) {
        // const MyComponent = () => { const onClick = useEffectEvent(...) }
        if (isInsideComponentOrHook(node)) {
          recordAllUseEffectEventFunctions(getScope(node));
        }
      },

      // @ts-expect-error parser-hermes produces these node types
      ComponentDeclaration(node) {
        // component MyComponent() { const onClick = useEffectEvent(...) }
        recordAllUseEffectEventFunctions(getScope(node));
      },

      // @ts-expect-error parser-hermes produces these node types
      HookDeclaration(node) {
        // hook useMyHook() { const onClick = useEffectEvent(...) }
        recordAllUseEffectEventFunctions(getScope(node));
      },
    };
  },
} satisfies Rule.RuleModule;

/**
 * Gets the static name of a function AST node. For function declarations it is
 * easy. For anonymous function expressions it is much harder. If you search for
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places
 * where JS gives anonymous function expressions names. We roughly detect the
 * same AST nodes with some exceptions to better fit our use case.
 */

function getFunctionName(node: Node) {
  if (
    // @ts-expect-error parser-hermes produces these node types
    node.type === "ComponentDeclaration"
    // @ts-expect-error parser-hermes produces these node types
    || node.type === "HookDeclaration"
    || node.type === "FunctionDeclaration"
    || (node.type === "FunctionExpression" && node.id)
  ) {
    // function useHook() {}
    // const whatever = function useHook() {};
    //
    // Function declaration or function expression names win over any
    // assignment statements or other renames.
    return node.id;
  } else if (
    node.type === "FunctionExpression"
    || node.type === "ArrowFunctionExpression"
  ) {
    if (
      node.parent?.type === "VariableDeclarator"
      && node.parent.init === node
    ) {
      // const useHook = () => {};
      return node.parent.id;
    } else if (
      node.parent?.type === "AssignmentExpression"
      && node.parent.right === node
      && node.parent.operator === "="
    ) {
      // useHook = () => {};
      return node.parent.left;
    } else if (
      node.parent?.type === "Property"
      && node.parent.value === node
      && !node.parent.computed
    ) {
      // {useHook: () => {}}
      // {useHook() {}}
      return node.parent.key;

      // NOTE: We could also support `ClassProperty` and `MethodDefinition`
      // here to be pedantic. However, hooks in a class are an anti-pattern. So
      // we don't allow it to error early.
      //
      // class {useHook = () => {}}
      // class {useHook() {}}
    } else if (
      node.parent?.type === "AssignmentPattern"
      && node.parent.right === node
      // @ts-expect-error Property computed does not exist on type `AssignmentPattern`.
      && !node.parent.computed
    ) {
      // const {useHook = () => {}} = {};
      // ({useHook = () => {}} = {});
      //
      // Kinda clowny, but we'd said we'd follow spec convention for
      // `IsAnonymousFunctionDefinition()` usage.
      return node.parent.left;
    } else {
      return undefined;
    }
  } else {
    return undefined;
  }
}

/**
 * Convenience function for peeking the last item in a stack.
 */
function last<T>(array: Array<T>): T {
  return array[array.length - 1] as T;
}

export default rule;

// Code Path Analyzer

// This code is a forked version of ESLints Code Path Analyzer which includes
// support for Component Syntax.

// Forked from: https://github.com/eslint/eslint/tree/main/lib/linter/code-path-analysis

// Copyright OpenJS Foundation and other contributors, <www.openjsf.org>

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// #region code-path-analysis/assert.js
function assert(cond) {
  if (!cond) throw new Error("Assertion violated.");
}

// #endregion
// #region code-path-analysis/code-path-segment.js
/**
 * Checks whether or not a given segment is reachable.
 * @param {CodePathSegment} segment A segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable$1(segment) {
  return segment.reachable;
}
/**
 * A code path segment.
 */
var CodePathSegment = class CodePathSegment {
  /**
   * @param {string} id An identifier.
   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
   *   This array includes unreachable segments.
   * @param {boolean} reachable A flag which shows this is reachable.
   */
  constructor(id, allPrevSegments, reachable) {
    /**
     * The identifier of this code path.
     * Rules use it to store additional information of each rule.
     * @type {string}
     */
    this.id = id;
    /**
     * An array of the next segments.
     * @type {CodePathSegment[]}
     */
    this.nextSegments = [];
    /**
     * An array of the previous segments.
     * @type {CodePathSegment[]}
     */
    this.prevSegments = allPrevSegments.filter(isReachable$1);
    /**
     * An array of the next segments.
     * This array includes unreachable segments.
     * @type {CodePathSegment[]}
     */
    this.allNextSegments = [];
    /**
     * An array of the previous segments.
     * This array includes unreachable segments.
     * @type {CodePathSegment[]}
     */
    this.allPrevSegments = allPrevSegments;
    /**
     * A flag which shows this is reachable.
     * @type {boolean}
     */
    this.reachable = reachable;
    Object.defineProperty(this, "internal", {
      value: {
        used: false,
        loopedPrevSegments: [],
      },
    });
  }
  /**
   * Checks a given previous segment is coming from the end of a loop.
   * @param {CodePathSegment} segment A previous segment to check.
   * @returns {boolean} `true` if the segment is coming from the end of a loop.
   */
  isLoopedPrevSegment(segment) {
    return this.internal.loopedPrevSegments.includes(segment);
  }
  /**
   * Creates the root segment.
   * @param {string} id An identifier.
   * @returns {CodePathSegment} The created segment.
   */
  static newRoot(id) {
    return new CodePathSegment(id, [], true);
  }
  /**
   * Creates a segment that follows given segments.
   * @param {string} id An identifier.
   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newNext(id, allPrevSegments) {
    return new CodePathSegment(
      id,
      CodePathSegment.flattenUnusedSegments(allPrevSegments),
      allPrevSegments.some(isReachable$1),
    );
  }
  /**
   * Creates an unreachable segment that follows given segments.
   * @param {string} id An identifier.
   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newUnreachable(id, allPrevSegments) {
    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
    CodePathSegment.markUsed(segment);
    return segment;
  }
  /**
   * Creates a segment that follows given segments.
   * This factory method does not connect with `allPrevSegments`.
   * But this inherits `reachable` flag.
   * @param {string} id An identifier.
   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newDisconnected(id, allPrevSegments) {
    return new CodePathSegment(id, [], allPrevSegments.some(isReachable$1));
  }
  /**
   * Makes a given segment being used.
   *
   * And this function registers the segment into the previous segments as a next.
   * @param {CodePathSegment} segment A segment to mark.
   * @returns {void}
   */
  static markUsed(segment) {
    if (segment.internal.used) return;
    segment.internal.used = true;
    let i;
    if (segment.reachable) {
      for (i = 0; i < segment.allPrevSegments.length; ++i) {
        const prevSegment = segment.allPrevSegments[i];
        prevSegment.allNextSegments.push(segment);
        prevSegment.nextSegments.push(segment);
      }
    } else {for (i = 0; i < segment.allPrevSegments.length; ++i) {
        segment.allPrevSegments[i].allNextSegments.push(segment);
      }}
  }
  /**
   * Marks a previous segment as looped.
   * @param {CodePathSegment} segment A segment.
   * @param {CodePathSegment} prevSegment A previous segment to mark.
   * @returns {void}
   */
  static markPrevSegmentAsLooped(segment, prevSegment) {
    segment.internal.loopedPrevSegments.push(prevSegment);
  }
  /**
   * Replaces unused segments with the previous segments of each unused segment.
   * @param {CodePathSegment[]} segments An array of segments to replace.
   * @returns {CodePathSegment[]} The replaced array.
   */
  static flattenUnusedSegments(segments) {
    const done = Object.create(null);
    const retv = [];
    for (let i = 0; i < segments.length; ++i) {
      const segment = segments[i];
      if (done[segment.id]) continue;
      if (!segment.internal.used) {
        for (let j = 0; j < segment.allPrevSegments.length; ++j) {
          const prevSegment = segment.allPrevSegments[j];
          if (!done[prevSegment.id]) {
            done[prevSegment.id] = true;
            retv.push(prevSegment);
          }
        }
      } else {
        done[segment.id] = true;
        retv.push(segment);
      }
    }
    return retv;
  }
};

// #endregion
// #region code-path-analysis/fork-context.js
/**
 * Gets whether or not a given segment is reachable.
 * @param {CodePathSegment} segment A segment to get.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}
/**
 * Creates new segments from the specific range of `context.segmentsList`.
 *
 * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and
 * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.
 * This `h` is from `b`, `d`, and `f`.
 * @param {ForkContext} context An instance.
 * @param {number} begin The first index of the previous segments.
 * @param {number} end The last index of the previous segments.
 * @param {Function} create A factory function of new segments.
 * @returns {CodePathSegment[]} New segments.
 */
function makeSegments(context, begin, end, create) {
  const list = context.segmentsList;
  const normalizedBegin = begin >= 0 ? begin : list.length + begin;
  const normalizedEnd = end >= 0 ? end : list.length + end;
  const segments = [];
  for (let i = 0; i < context.count; ++i) {
    const allPrevSegments = [];
    for (let j = normalizedBegin; j <= normalizedEnd; ++j) allPrevSegments.push(list[j][i]);
    segments.push(create(context.idGenerator.next(), allPrevSegments));
  }
  return segments;
}
/**
 * `segments` becomes doubly in a `finally` block. Then if a code path exits by a
 * control statement (such as `break`, `continue`) from the `finally` block, the
 * destination's segments may be half of the source segments. In that case, this
 * merges segments.
 * @param {ForkContext} context An instance.
 * @param {CodePathSegment[]} segments Segments to merge.
 * @returns {CodePathSegment[]} The merged segments.
 */
function mergeExtraSegments(context, segments) {
  let currentSegments = segments;
  while (currentSegments.length > context.count) {
    const merged = [];
    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {
      merged.push(
        CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]),
      );
    }
    currentSegments = merged;
  }
  return currentSegments;
}
/**
 * A class to manage forking.
 */
var ForkContext = class ForkContext {
  /**
   * @param {IdGenerator} idGenerator An identifier generator for segments.
   * @param {ForkContext|null} upper An upper fork context.
   * @param {number} count A number of parallel segments.
   */
  constructor(idGenerator, upper, count) {
    this.idGenerator = idGenerator;
    this.upper = upper;
    this.count = count;
    this.segmentsList = [];
  }
  /**
   * The head segments.
   * @type {CodePathSegment[]}
   */
  get head() {
    const list = this.segmentsList;
    return list.length === 0 ? [] : list[list.length - 1];
  }
  /**
   * A flag which shows empty.
   * @type {boolean}
   */
  get empty() {
    return this.segmentsList.length === 0;
  }
  /**
   * A flag which shows reachable.
   * @type {boolean}
   */
  get reachable() {
    const segments = this.head;
    return segments.length > 0 && segments.some(isReachable);
  }
  /**
   * Creates new segments from this context.
   * @param {number} begin The first index of previous segments.
   * @param {number} end The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeNext(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newNext);
  }
  /**
   * Creates new segments from this context.
   * The new segments is always unreachable.
   * @param {number} begin The first index of previous segments.
   * @param {number} end The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeUnreachable(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
  }
  /**
   * Creates new segments from this context.
   * The new segments don't have connections for previous segments.
   * But these inherit the reachable flag from this context.
   * @param {number} begin The first index of previous segments.
   * @param {number} end The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeDisconnected(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
  }
  /**
   * Adds segments into this context.
   * The added segments become the head.
   * @param {CodePathSegment[]} segments Segments to add.
   * @returns {void}
   */
  add(segments) {
    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.push(mergeExtraSegments(this, segments));
  }
  /**
   * Replaces the head segments with given segments.
   * The current head segments are removed.
   * @param {CodePathSegment[]} segments Segments to add.
   * @returns {void}
   */
  replaceHead(segments) {
    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
  }
  /**
   * Adds all segments of a given fork context into this context.
   * @param {ForkContext} context A fork context to add.
   * @returns {void}
   */
  addAll(context) {
    assert(context.count === this.count);
    const source = context.segmentsList;
    for (let i = 0; i < source.length; ++i) this.segmentsList.push(source[i]);
  }
  /**
   * Clears all segments in this context.
   * @returns {void}
   */
  clear() {
    this.segmentsList = [];
  }
  /**
   * Creates the root fork context.
   * @param {IdGenerator} idGenerator An identifier generator for segments.
   * @returns {ForkContext} New fork context.
   */
  static newRoot(idGenerator) {
    const context = new ForkContext(idGenerator, null, 1);
    context.add([CodePathSegment.newRoot(idGenerator.next())]);
    return context;
  }
  /**
   * Creates an empty fork context preceded by a given context.
   * @param {ForkContext} parentContext The parent fork context.
   * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.
   * @returns {ForkContext} New fork context.
   */
  static newEmpty(parentContext, forkLeavingPath) {
    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
  }
};

// #endregion
// #region code-path-analysis/code-path-state.js
/**
 * Adds given segments into the `dest` array.
 * If the `others` array does not includes the given segments, adds to the `all`
 * array as well.
 *
 * This adds only reachable and used segments.
 * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).
 * @param {CodePathSegment[]} segments Segments to add.
 * @returns {void}
 */
function addToReturnedOrThrown(dest, others, all, segments) {
  for (let i = 0; i < segments.length; ++i) {
    const segment = segments[i];
    dest.push(segment);
    if (!others.includes(segment)) all.push(segment);
  }
}
/**
 * Gets a loop-context for a `continue` statement.
 * @param {CodePathState} state A state to get.
 * @param {string} label The label of a `continue` statement.
 * @returns {LoopContext} A loop-context for a `continue` statement.
 */
function getContinueContext(state, label) {
  if (!label) return state.loopContext;
  let context = state.loopContext;
  while (context) {
    if (context.label === label) return context;
    context = context.upper;
  }
  /* c8 ignore next */
  return null;
}
/**
 * Gets a context for a `break` statement.
 * @param {CodePathState} state A state to get.
 * @param {string} label The label of a `break` statement.
 * @returns {LoopContext|SwitchContext} A context for a `break` statement.
 */
function getBreakContext(state, label) {
  let context = state.breakContext;
  while (context) {
    if (label ? context.label === label : context.breakable) return context;
    context = context.upper;
  }
  /* c8 ignore next */
  return null;
}
/**
 * Gets a context for a `return` statement.
 * @param {CodePathState} state A state to get.
 * @returns {TryContext|CodePathState} A context for a `return` statement.
 */
function getReturnContext(state) {
  let context = state.tryContext;
  while (context) {
    if (context.hasFinalizer && context.position !== "finally") return context;
    context = context.upper;
  }
  return state;
}
/**
 * Gets a context for a `throw` statement.
 * @param {CodePathState} state A state to get.
 * @returns {TryContext|CodePathState} A context for a `throw` statement.
 */
function getThrowContext(state) {
  let context = state.tryContext;
  while (context) {
    if (context.position === "try" || context.hasFinalizer && context.position === "catch") return context;
    context = context.upper;
  }
  return state;
}
/**
 * Removes a given element from a given array.
 * @param {any[]} xs An array to remove the specific element.
 * @param {any} x An element to be removed.
 * @returns {void}
 */
function remove(xs, x) {
  xs.splice(xs.indexOf(x), 1);
}
/**
 * Disconnect given segments.
 *
 * This is used in a process for switch statements.
 * If there is the "default" chunk before other cases, the order is different
 * between node's and running's.
 * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.
 * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.
 * @returns {void}
 */
function removeConnection(prevSegments, nextSegments) {
  for (let i = 0; i < prevSegments.length; ++i) {
    const prevSegment = prevSegments[i];
    const nextSegment = nextSegments[i];
    remove(prevSegment.nextSegments, nextSegment);
    remove(prevSegment.allNextSegments, nextSegment);
    remove(nextSegment.prevSegments, prevSegment);
    remove(nextSegment.allPrevSegments, prevSegment);
  }
}
/**
 * Creates looping path.
 * @param {CodePathState} state The instance.
 * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.
 * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.
 * @returns {void}
 */
function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
  const end = Math.min(fromSegments.length, toSegments.length);
  for (let i = 0; i < end; ++i) {
    const fromSegment = fromSegments[i];
    const toSegment = toSegments[i];
    if (toSegment.reachable) fromSegment.nextSegments.push(toSegment);
    if (fromSegment.reachable) toSegment.prevSegments.push(fromSegment);
    fromSegment.allNextSegments.push(toSegment);
    toSegment.allPrevSegments.push(fromSegment);
    if (toSegment.allPrevSegments.length >= 2) CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
    state.notifyLooped(fromSegment, toSegment);
  }
}
/**
 * Finalizes segments of `test` chunk of a ForStatement.
 *
 * - Adds `false` paths to paths which are leaving from the loop.
 * - Sets `true` paths to paths which go to the body.
 * @param {LoopContext} context A loop context to modify.
 * @param {ChoiceContext} choiceContext A choice context of this loop.
 * @param {CodePathSegment[]} head The current head paths.
 * @returns {void}
 */
function finalizeTestSegmentsOfFor(context, choiceContext, head) {
  if (!choiceContext.processed) {
    choiceContext.trueForkContext.add(head);
    choiceContext.falseForkContext.add(head);
    choiceContext.qqForkContext.add(head);
  }
  if (context.test !== true) context.brokenForkContext.addAll(choiceContext.falseForkContext);
  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}
/**
 * A class which manages state to analyze code paths.
 */
var CodePathState = class {
  /**
   * @param {IdGenerator} idGenerator An id generator to generate id for code
   *   path segments.
   * @param {Function} onLooped A callback function to notify looping.
   */
  constructor(idGenerator, onLooped) {
    this.idGenerator = idGenerator;
    this.notifyLooped = onLooped;
    this.forkContext = ForkContext.newRoot(idGenerator);
    this.choiceContext = null;
    this.switchContext = null;
    this.tryContext = null;
    this.loopContext = null;
    this.breakContext = null;
    this.chainContext = null;
    this.currentSegments = [];
    this.initialSegment = this.forkContext.head[0];
    const final = this.finalSegments = [];
    const returned = this.returnedForkContext = [];
    const thrown = this.thrownForkContext = [];
    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
  }
  /**
   * The head segments.
   * @type {CodePathSegment[]}
   */
  get headSegments() {
    return this.forkContext.head;
  }
  /**
   * The parent forking context.
   * This is used for the root of new forks.
   * @type {ForkContext}
   */
  get parentForkContext() {
    const current = this.forkContext;
    return current && current.upper;
  }
  /**
   * Creates and stacks new forking context.
   * @param {boolean} forkLeavingPath A flag which shows being in a
   *   "finally" block.
   * @returns {ForkContext} The created context.
   */
  pushForkContext(forkLeavingPath) {
    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);
    return this.forkContext;
  }
  /**
   * Pops and merges the last forking context.
   * @returns {ForkContext} The last context.
   */
  popForkContext() {
    const lastContext = this.forkContext;
    this.forkContext = lastContext.upper;
    this.forkContext.replaceHead(lastContext.makeNext(0, -1));
    return lastContext;
  }
  /**
   * Creates a new path.
   * @returns {void}
   */
  forkPath() {
    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
  }
  /**
   * Creates a bypass path.
   * This is used for such as IfStatement which does not have "else" chunk.
   * @returns {void}
   */
  forkBypassPath() {
    this.forkContext.add(this.parentForkContext.head);
  }
  /**
   * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),
   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
   *
   * LogicalExpressions have cases that it goes different paths between the
   * `true` case and the `false` case.
   *
   * For Example:
   *
   *     if (a || b) {
   *         foo();
   *     } else {
   *         bar();
   *     }
   *
   * In this case, `b` is evaluated always in the code path of the `else`
   * block, but it's not so in the code path of the `if` block.
   * So there are 3 paths.
   *
   *     a -> foo();
   *     a -> b -> foo();
   *     a -> b -> bar();
   * @param {string} kind A kind string.
   *   If the new context is LogicalExpression's or AssignmentExpression's, this is `"&&"` or `"||"` or `"??"`.
   *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
   *   Otherwise, this is `"loop"`.
   * @param {boolean} isForkingAsResult A flag that shows that goes different
   *   paths between `true` and `false`.
   * @returns {void}
   */
  pushChoiceContext(kind, isForkingAsResult) {
    this.choiceContext = {
      upper: this.choiceContext,
      kind,
      isForkingAsResult,
      trueForkContext: ForkContext.newEmpty(this.forkContext),
      falseForkContext: ForkContext.newEmpty(this.forkContext),
      qqForkContext: ForkContext.newEmpty(this.forkContext),
      processed: false,
    };
  }
  /**
   * Pops the last choice context and finalizes it.
   * @throws {Error} (Unreachable.)
   * @returns {ChoiceContext} The popped context.
   */
  popChoiceContext() {
    const context = this.choiceContext;
    this.choiceContext = context.upper;
    const forkContext = this.forkContext;
    const headSegments = forkContext.head;
    switch (context.kind) {
      case "&&":
      case "||":
      case "??":
        if (!context.processed) {
          context.trueForkContext.add(headSegments);
          context.falseForkContext.add(headSegments);
          context.qqForkContext.add(headSegments);
        }
        if (context.isForkingAsResult) {
          const parentContext = this.choiceContext;
          parentContext.trueForkContext.addAll(context.trueForkContext);
          parentContext.falseForkContext.addAll(context.falseForkContext);
          parentContext.qqForkContext.addAll(context.qqForkContext);
          parentContext.processed = true;
          return context;
        }
        break;
      case "test":
        if (!context.processed) {
          context.trueForkContext.clear();
          context.trueForkContext.add(headSegments);
        } else {
          context.falseForkContext.clear();
          context.falseForkContext.add(headSegments);
        }
        break;
      case "loop":
        return context;
      default:
        throw new Error("unreachable");
    }
    const prevForkContext = context.trueForkContext;
    prevForkContext.addAll(context.falseForkContext);
    forkContext.replaceHead(prevForkContext.makeNext(0, -1));
    return context;
  }
  /**
   * Makes a code path segment of the right-hand operand of a logical
   * expression.
   * @throws {Error} (Unreachable.)
   * @returns {void}
   */
  makeLogicalRight() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;
    if (context.processed) {
      let prevForkContext;
      switch (context.kind) {
        case "&&":
          prevForkContext = context.trueForkContext;
          break;
        case "||":
          prevForkContext = context.falseForkContext;
          break;
        case "??":
          prevForkContext = context.qqForkContext;
          break;
        default:
          throw new Error("unreachable");
      }
      forkContext.replaceHead(prevForkContext.makeNext(0, -1));
      prevForkContext.clear();
      context.processed = false;
    } else {
      switch (context.kind) {
        case "&&":
          context.falseForkContext.add(forkContext.head);
          break;
        case "||":
          context.trueForkContext.add(forkContext.head);
          break;
        case "??":
          context.trueForkContext.add(forkContext.head);
          context.falseForkContext.add(forkContext.head);
          break;
        default:
          throw new Error("unreachable");
      }
      forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }
  }
  /**
   * Makes a code path segment of the `if` block.
   * @returns {void}
   */
  makeIfConsequent() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;
    if (!context.processed) {
      context.trueForkContext.add(forkContext.head);
      context.falseForkContext.add(forkContext.head);
      context.qqForkContext.add(forkContext.head);
    }
    context.processed = false;
    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
  }
  /**
   * Makes a code path segment of the `else` block.
   * @returns {void}
   */
  makeIfAlternate() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;
    context.trueForkContext.clear();
    context.trueForkContext.add(forkContext.head);
    context.processed = true;
    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
  }
  /**
   * Push a new `ChainExpression` context to the stack.
   * This method is called on entering to each `ChainExpression` node.
   * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.
   * @returns {void}
   */
  pushChainContext() {
    this.chainContext = {
      upper: this.chainContext,
      countChoiceContexts: 0,
    };
  }
  /**
   * Pop a `ChainExpression` context from the stack.
   * This method is called on exiting from each `ChainExpression` node.
   * This merges all forks of the last optional chaining.
   * @returns {void}
   */
  popChainContext() {
    const context = this.chainContext;
    this.chainContext = context.upper;
    for (let i = context.countChoiceContexts; i > 0; --i) this.popChoiceContext();
  }
  /**
   * Create a choice context for optional access.
   * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.
   * This creates a choice context as similar to `LogicalExpression[operator="??"]` node.
   * @returns {void}
   */
  makeOptionalNode() {
    if (this.chainContext) {
      this.chainContext.countChoiceContexts += 1;
      this.pushChoiceContext("??", false);
    }
  }
  /**
   * Create a fork.
   * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.
   * @returns {void}
   */
  makeOptionalRight() {
    if (this.chainContext) this.makeLogicalRight();
  }
  /**
   * Creates a context object of SwitchStatement and stacks it.
   * @param {boolean} hasCase `true` if the switch statement has one or more
   *   case parts.
   * @param {string|null} label The label text.
   * @returns {void}
   */
  pushSwitchContext(hasCase, label) {
    this.switchContext = {
      upper: this.switchContext,
      hasCase,
      defaultSegments: null,
      defaultBodySegments: null,
      foundDefault: false,
      lastIsDefault: false,
      countForks: 0,
    };
    this.pushBreakContext(true, label);
  }
  /**
   * Pops the last context of SwitchStatement and finalizes it.
   *
   * - Disposes all forking stack for `case` and `default`.
   * - Creates the next code path segment from `context.brokenForkContext`.
   * - If the last `SwitchCase` node is not a `default` part, creates a path
   *   to the `default` body.
   * @returns {void}
   */
  popSwitchContext() {
    const context = this.switchContext;
    this.switchContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;
    if (context.countForks === 0) {
      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.makeNext(-1, -1));
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
      return;
    }
    const lastSegments = forkContext.head;
    this.forkBypassPath();
    const lastCaseSegments = forkContext.head;
    brokenForkContext.add(lastSegments);
    if (!context.lastIsDefault) {
      if (context.defaultBodySegments) {
        removeConnection(context.defaultSegments, context.defaultBodySegments);
        makeLooped(this, lastCaseSegments, context.defaultBodySegments);
      } else brokenForkContext.add(lastCaseSegments);
    }
    for (let i = 0; i < context.countForks; ++i) this.forkContext = this.forkContext.upper;
    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
  }
  /**
   * Makes a code path segment for a `SwitchCase` node.
   * @param {boolean} isEmpty `true` if the body is empty.
   * @param {boolean} isDefault `true` if the body is the default case.
   * @returns {void}
   */
  makeSwitchCaseBody(isEmpty, isDefault) {
    const context = this.switchContext;
    if (!context.hasCase) return;
    const parentForkContext = this.forkContext;
    const forkContext = this.pushForkContext();
    forkContext.add(parentForkContext.makeNext(0, -1));
    if (isDefault) {
      context.defaultSegments = parentForkContext.head;
      if (isEmpty) context.foundDefault = true;
      else context.defaultBodySegments = forkContext.head;
    } else if (!isEmpty && context.foundDefault) {
      context.foundDefault = false;
      context.defaultBodySegments = forkContext.head;
    }
    context.lastIsDefault = isDefault;
    context.countForks += 1;
  }
  /**
   * Creates a context object of TryStatement and stacks it.
   * @param {boolean} hasFinalizer `true` if the try statement has a
   *   `finally` block.
   * @returns {void}
   */
  pushTryContext(hasFinalizer) {
    this.tryContext = {
      upper: this.tryContext,
      position: "try",
      hasFinalizer,
      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,
      thrownForkContext: ForkContext.newEmpty(this.forkContext),
      lastOfTryIsReachable: false,
      lastOfCatchIsReachable: false,
    };
  }
  /**
   * Pops the last context of TryStatement and finalizes it.
   * @returns {void}
   */
  popTryContext() {
    const context = this.tryContext;
    this.tryContext = context.upper;
    if (context.position === "catch") {
      this.popForkContext();
      return;
    }
    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;
    if (returned.empty && thrown.empty) return;
    const headSegments = this.forkContext.head;
    this.forkContext = this.forkContext.upper;
    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
    if (!returned.empty) getReturnContext(this).returnedForkContext.add(leavingSegments);
    if (!thrown.empty) getThrowContext(this).thrownForkContext.add(leavingSegments);
    this.forkContext.replaceHead(normalSegments);
    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) this.forkContext.makeUnreachable();
  }
  /**
   * Makes a code path segment for a `catch` block.
   * @returns {void}
   */
  makeCatchBlock() {
    const context = this.tryContext;
    const forkContext = this.forkContext;
    const thrown = context.thrownForkContext;
    context.position = "catch";
    context.thrownForkContext = ForkContext.newEmpty(forkContext);
    context.lastOfTryIsReachable = forkContext.reachable;
    thrown.add(forkContext.head);
    const thrownSegments = thrown.makeNext(0, -1);
    this.pushForkContext();
    this.forkBypassPath();
    this.forkContext.add(thrownSegments);
  }
  /**
   * Makes a code path segment for a `finally` block.
   *
   * In the `finally` block, parallel paths are created. The parallel paths
   * are used as leaving-paths. The leaving-paths are paths from `return`
   * statements and `throw` statements in a `try` block or a `catch` block.
   * @returns {void}
   */
  makeFinallyBlock() {
    const context = this.tryContext;
    let forkContext = this.forkContext;
    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;
    const headOfLeavingSegments = forkContext.head;
    if (context.position === "catch") {
      this.popForkContext();
      forkContext = this.forkContext;
      context.lastOfCatchIsReachable = forkContext.reachable;
    } else context.lastOfTryIsReachable = forkContext.reachable;
    context.position = "finally";
    if (returned.empty && thrown.empty) return;
    const segments = forkContext.makeNext(-1, -1);
    for (let i = 0; i < forkContext.count; ++i) {
      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
      for (let j = 0; j < returned.segmentsList.length; ++j) prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
      for (let j = 0; j < thrown.segmentsList.length; ++j) prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
    }
    this.pushForkContext(true);
    this.forkContext.add(segments);
  }
  /**
   * Makes a code path segment from the first throwable node to the `catch`
   * block or the `finally` block.
   * @returns {void}
   */
  makeFirstThrowablePathInTryBlock() {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) return;
    const context = getThrowContext(this);
    if (context === this || context.position !== "try" || !context.thrownForkContext.empty) return;
    context.thrownForkContext.add(forkContext.head);
    forkContext.replaceHead(forkContext.makeNext(-1, -1));
  }
  /**
   * Creates a context object of a loop statement and stacks it.
   * @param {string} type The type of the node which was triggered. One of
   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
   *   and `ForStatement`.
   * @param {string|null} label A label of the node which was triggered.
   * @throws {Error} (Unreachable - unknown type.)
   * @returns {void}
   */
  pushLoopContext(type, label) {
    const forkContext = this.forkContext;
    const breakContext = this.pushBreakContext(true, label);
    switch (type) {
      case "WhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext,
        };
        break;
      case "DoWhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          entrySegments: null,
          continueForkContext: ForkContext.newEmpty(forkContext),
          brokenForkContext: breakContext.brokenForkContext,
        };
        break;
      case "ForStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          endOfInitSegments: null,
          testSegments: null,
          endOfTestSegments: null,
          updateSegments: null,
          endOfUpdateSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext,
        };
        break;
      case "ForInStatement":
      case "ForOfStatement":
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          prevSegments: null,
          leftSegments: null,
          endOfLeftSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext,
        };
        break;
      default:
        throw new Error(`unknown type: "${type}"`);
    }
  }
  /**
   * Pops the last context of a loop statement and finalizes it.
   * @throws {Error} (Unreachable - unknown type.)
   * @returns {void}
   */
  popLoopContext() {
    const context = this.loopContext;
    this.loopContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;
    switch (context.type) {
      case "WhileStatement":
      case "ForStatement":
        this.popChoiceContext();
        makeLooped(this, forkContext.head, context.continueDestSegments);
        break;
      case "DoWhileStatement": {
        const choiceContext = this.popChoiceContext();
        if (!choiceContext.processed) {
          choiceContext.trueForkContext.add(forkContext.head);
          choiceContext.falseForkContext.add(forkContext.head);
        }
        if (context.test !== true) brokenForkContext.addAll(choiceContext.falseForkContext);
        const segmentsList = choiceContext.trueForkContext.segmentsList;
        for (let i = 0; i < segmentsList.length; ++i) makeLooped(this, segmentsList[i], context.entrySegments);
        break;
      }
      case "ForInStatement":
      case "ForOfStatement":
        brokenForkContext.add(forkContext.head);
        makeLooped(this, forkContext.head, context.leftSegments);
        break;
      default:
        throw new Error("unreachable");
    }
    if (brokenForkContext.empty) forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    else forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
  }
  /**
   * Makes a code path segment for the test part of a WhileStatement.
   * @param {boolean|undefined} test The test value (only when constant).
   * @returns {void}
   */
  makeWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const testSegments = forkContext.makeNext(0, -1);
    context.test = test;
    context.continueDestSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }
  /**
   * Makes a code path segment for the body part of a WhileStatement.
   * @returns {void}
   */
  makeWhileBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;
    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(forkContext.head);
      choiceContext.falseForkContext.add(forkContext.head);
    }
    if (context.test !== true) context.brokenForkContext.addAll(choiceContext.falseForkContext);
    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
  }
  /**
   * Makes a code path segment for the body part of a DoWhileStatement.
   * @returns {void}
   */
  makeDoWhileBody() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const bodySegments = forkContext.makeNext(-1, -1);
    context.entrySegments = bodySegments;
    forkContext.replaceHead(bodySegments);
  }
  /**
   * Makes a code path segment for the test part of a DoWhileStatement.
   * @param {boolean|undefined} test The test value (only when constant).
   * @returns {void}
   */
  makeDoWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    context.test = test;
    if (!context.continueForkContext.empty) {
      context.continueForkContext.add(forkContext.head);
      const testSegments = context.continueForkContext.makeNext(0, -1);
      forkContext.replaceHead(testSegments);
    }
  }
  /**
   * Makes a code path segment for the test part of a ForStatement.
   * @param {boolean|undefined} test The test value (only when constant).
   * @returns {void}
   */
  makeForTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const endOfInitSegments = forkContext.head;
    const testSegments = forkContext.makeNext(-1, -1);
    context.test = test;
    context.endOfInitSegments = endOfInitSegments;
    context.continueDestSegments = context.testSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }
  /**
   * Makes a code path segment for the update part of a ForStatement.
   * @returns {void}
   */
  makeForUpdate() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;
    if (context.testSegments) finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
    else context.endOfInitSegments = forkContext.head;
    const updateSegments = forkContext.makeDisconnected(-1, -1);
    context.continueDestSegments = context.updateSegments = updateSegments;
    forkContext.replaceHead(updateSegments);
  }
  /**
   * Makes a code path segment for the body part of a ForStatement.
   * @returns {void}
   */
  makeForBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;
    if (context.updateSegments) {
      context.endOfUpdateSegments = forkContext.head;
      if (context.testSegments) makeLooped(this, context.endOfUpdateSegments, context.testSegments);
    } else if (context.testSegments) finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
    else context.endOfInitSegments = forkContext.head;
    let bodySegments = context.endOfTestSegments;
    if (!bodySegments) {
      const prevForkContext = ForkContext.newEmpty(forkContext);
      prevForkContext.add(context.endOfInitSegments);
      if (context.endOfUpdateSegments) prevForkContext.add(context.endOfUpdateSegments);
      bodySegments = prevForkContext.makeNext(0, -1);
    }
    context.continueDestSegments = context.continueDestSegments || bodySegments;
    forkContext.replaceHead(bodySegments);
  }
  /**
   * Makes a code path segment for the left part of a ForInStatement and a
   * ForOfStatement.
   * @returns {void}
   */
  makeForInOfLeft() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const leftSegments = forkContext.makeDisconnected(-1, -1);
    context.prevSegments = forkContext.head;
    context.leftSegments = context.continueDestSegments = leftSegments;
    forkContext.replaceHead(leftSegments);
  }
  /**
   * Makes a code path segment for the right part of a ForInStatement and a
   * ForOfStatement.
   * @returns {void}
   */
  makeForInOfRight() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const temp = ForkContext.newEmpty(forkContext);
    temp.add(context.prevSegments);
    const rightSegments = temp.makeNext(-1, -1);
    context.endOfLeftSegments = forkContext.head;
    forkContext.replaceHead(rightSegments);
  }
  /**
   * Makes a code path segment for the body part of a ForInStatement and a
   * ForOfStatement.
   * @returns {void}
   */
  makeForInOfBody() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const temp = ForkContext.newEmpty(forkContext);
    temp.add(context.endOfLeftSegments);
    const bodySegments = temp.makeNext(-1, -1);
    makeLooped(this, forkContext.head, context.leftSegments);
    context.brokenForkContext.add(forkContext.head);
    forkContext.replaceHead(bodySegments);
  }
  /**
   * Creates new context for BreakStatement.
   * @param {boolean} breakable The flag to indicate it can break by
   *      an unlabeled BreakStatement.
   * @param {string|null} label The label of this context.
   * @returns {Object} The new context.
   */
  pushBreakContext(breakable, label) {
    this.breakContext = {
      upper: this.breakContext,
      breakable,
      label,
      brokenForkContext: ForkContext.newEmpty(this.forkContext),
    };
    return this.breakContext;
  }
  /**
   * Removes the top item of the break context stack.
   * @returns {Object} The removed context.
   */
  popBreakContext() {
    const context = this.breakContext;
    const forkContext = this.forkContext;
    this.breakContext = context.upper;
    if (!context.breakable) {
      const brokenForkContext = context.brokenForkContext;
      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }
    return context;
  }
  /**
   * Makes a path for a `break` statement.
   *
   * It registers the head segment to a context of `break`.
   * It makes new unreachable segment, then it set the head with the segment.
   * @param {string} label A label of the break statement.
   * @returns {void}
   */
  makeBreak(label) {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) return;
    const context = getBreakContext(this, label);
    if (context) context.brokenForkContext.add(forkContext.head);
    /* c8 ignore next */
    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }
  /**
   * Makes a path for a `continue` statement.
   *
   * It makes a looping path.
   * It makes new unreachable segment, then it set the head with the segment.
   * @param {string} label A label of the continue statement.
   * @returns {void}
   */
  makeContinue(label) {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) return;
    const context = getContinueContext(this, label);
    if (context) {
      if (context.continueDestSegments) {
        makeLooped(this, forkContext.head, context.continueDestSegments);
        if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
          context.brokenForkContext.add(forkContext.head);
        }
      } else context.continueForkContext.add(forkContext.head);
    }
    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }
  /**
   * Makes a path for a `return` statement.
   *
   * It registers the head segment to a context of `return`.
   * It makes new unreachable segment, then it set the head with the segment.
   * @returns {void}
   */
  makeReturn() {
    const forkContext = this.forkContext;
    if (forkContext.reachable) {
      getReturnContext(this).returnedForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }
  /**
   * Makes a path for a `throw` statement.
   *
   * It registers the head segment to a context of `throw`.
   * It makes new unreachable segment, then it set the head with the segment.
   * @returns {void}
   */
  makeThrow() {
    const forkContext = this.forkContext;
    if (forkContext.reachable) {
      getThrowContext(this).thrownForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }
  /**
   * Makes the final path.
   * @returns {void}
   */
  makeFinal() {
    const segments = this.currentSegments;
    if (segments.length > 0 && segments[0].reachable) this.returnedForkContext.add(segments);
  }
};

// #endregion
// #region code-path-analysis/id-generator.js
/**
 * A generator for unique ids.
 */
var IdGenerator = class {
  /**
   * @param {string} prefix Optional. A prefix of generated ids.
   */
  constructor(prefix) {
    this.prefix = String(prefix);
    this.n = 0;
  }
  /**
   * Generates id.
   * @returns {string} A generated id.
   */
  next() {
    this.n = 1 + this.n | 0;
    /* c8 ignore start */
    if (this.n < 0) this.n = 1;
    return this.prefix + this.n;
  }
};

// #endregion
// #region code-path-analysis/code-path.js
/**
 * A code path.
 */
var CodePath = class {
  /**
   * Creates a new instance.
   * @param {Object} options Options for the function (see below).
   * @param {string} options.id An identifier.
   * @param {string} options.origin The type of code path origin.
   * @param {CodePath|null} options.upper The code path of the upper function scope.
   * @param {Function} options.onLooped A callback function to notify looping.
   */
  constructor({ id, origin, upper, onLooped }) {
    /**
     * The identifier of this code path.
     * Rules use it to store additional information of each rule.
     * @type {string}
     */
    this.id = id;
    /**
     * The reason that this code path was started. May be "program",
     * "function", "class-field-initializer", or "class-static-block".
     * @type {string}
     */
    this.origin = origin;
    /**
     * The code path of the upper function scope.
     * @type {CodePath|null}
     */
    this.upper = upper;
    /**
     * The code paths of nested function scopes.
     * @type {CodePath[]}
     */
    this.childCodePaths = [];
    Object.defineProperty(this, "internal", { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) });
    if (upper) upper.childCodePaths.push(this);
  }
  /**
   * Gets the state of a given code path.
   * @param {CodePath} codePath A code path to get.
   * @returns {CodePathState} The state of the code path.
   */
  static getState(codePath) {
    return codePath.internal;
  }
  /**
   * The initial code path segment.
   * @type {CodePathSegment}
   */
  get initialSegment() {
    return this.internal.initialSegment;
  }
  /**
   * Final code path segments.
   * This array is a mix of `returnedSegments` and `thrownSegments`.
   * @type {CodePathSegment[]}
   */
  get finalSegments() {
    return this.internal.finalSegments;
  }
  /**
   * Final code path segments which is with `return` statements.
   * This array contains the last path segment if it's reachable.
   * Since the reachable last path returns `undefined`.
   * @type {CodePathSegment[]}
   */
  get returnedSegments() {
    return this.internal.returnedForkContext;
  }
  /**
   * Final code path segments which is with `throw` statements.
   * @type {CodePathSegment[]}
   */
  get thrownSegments() {
    return this.internal.thrownForkContext;
  }
  /**
   * Current code path segments.
   * @type {CodePathSegment[]}
   */
  get currentSegments() {
    return this.internal.currentSegments;
  }
  /**
   * Traverses all segments in this code path.
   *
   *     codePath.traverseSegments(function(segment, controller) {
   *         // do something.
   *     });
   *
   * This method enumerates segments in order from the head.
   *
   * The `controller` object has two methods.
   *
   * - `controller.skip()` - Skip the following segments in this branch.
   * - `controller.break()` - Skip all following segments.
   * @param {Object} [options] Omittable.
   * @param {CodePathSegment} [options.first] The first segment to traverse.
   * @param {CodePathSegment} [options.last] The last segment to traverse.
   * @param {Function} callback A callback function.
   * @returns {void}
   */
  traverseSegments(options, callback) {
    let resolvedOptions;
    let resolvedCallback;
    if (typeof options === "function") {
      resolvedCallback = options;
      resolvedOptions = {};
    } else {
      resolvedOptions = options || {};
      resolvedCallback = callback;
    }
    const startSegment = resolvedOptions.first || this.internal.initialSegment;
    const lastSegment = resolvedOptions.last;
    let item = null;
    let index = 0;
    let end = 0;
    let segment = null;
    const visited = Object.create(null);
    const stack = [[startSegment, 0]];
    let skippedSegment = null;
    let broken = false;
    const controller = {
      skip() {
        if (stack.length <= 1) broken = true;
        else skippedSegment = stack[stack.length - 2][0];
      },
      break() {
        broken = true;
      },
    };
    /**
     * Checks a given previous segment has been visited.
     * @param {CodePathSegment} prevSegment A previous segment to check.
     * @returns {boolean} `true` if the segment has been visited.
     */
    function isVisited(prevSegment) {
      return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
    }
    while (stack.length > 0) {
      item = stack[stack.length - 1];
      segment = item[0];
      index = item[1];
      if (index === 0) {
        if (visited[segment.id]) {
          stack.pop();
          continue;
        }
        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
          stack.pop();
          continue;
        }
        if (skippedSegment && segment.prevSegments.includes(skippedSegment)) skippedSegment = null;
        visited[segment.id] = true;
        if (!skippedSegment) {
          resolvedCallback.call(this, segment, controller);
          if (segment === lastSegment) controller.skip();
          if (broken) break;
        }
      }
      end = segment.nextSegments.length - 1;
      if (index < end) {
        item[1] += 1;
        stack.push([segment.nextSegments[index], 0]);
      } else if (index === end) {
        item[0] = segment.nextSegments[index];
        item[1] = 0;
      } else stack.pop();
    }
  }
};

// #endregion
// #region code-path-analysis/code-path-analyzer.js
const breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
/**
 * Checks whether or not a given node is a `case` node (not `default` node).
 * @param {ASTNode} node A `SwitchCase` node to check.
 * @returns {boolean} `true` if the node is a `case` node (not `default` node).
 */
function isCaseNode(node) {
  return Boolean(node.test);
}
/**
 * Checks if a given node appears as the value of a PropertyDefinition node.
 * @param {ASTNode} node THe node to check.
 * @returns {boolean} `true` if the node is a PropertyDefinition value,
 *      false if not.
 */
function isPropertyDefinitionValue(node) {
  const parent = node.parent;
  return parent && parent.type === "PropertyDefinition" && parent.value === node;
}
/**
 * Checks whether the given logical operator is taken into account for the code
 * path analysis.
 * @param {string} operator The operator found in the LogicalExpression node
 * @returns {boolean} `true` if the operator is "&&" or "||" or "??"
 */
function isHandledLogicalOperator(operator) {
  return operator === "&&" || operator === "||" || operator === "??";
}
/**
 * Checks whether the given assignment operator is a logical assignment operator.
 * Logical assignments are taken into account for the code path analysis
 * because of their short-circuiting semantics.
 * @param {string} operator The operator found in the AssignmentExpression node
 * @returns {boolean} `true` if the operator is "&&=" or "||=" or "??="
 */
function isLogicalAssignmentOperator(operator) {
  return operator === "&&=" || operator === "||=" || operator === "??=";
}
/**
 * Gets the label if the parent node of a given node is a LabeledStatement.
 * @param {ASTNode} node A node to get.
 * @returns {string|null} The label or `null`.
 */
function getLabel(node) {
  if (node.parent.type === "LabeledStatement") return node.parent.label.name;
  return null;
}
/**
 * Checks whether or not a given logical expression node goes different path
 * between the `true` case and the `false` case.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is a test of a choice statement.
 */
function isForkingByTrueOrFalse(node) {
  const parent = node.parent;
  switch (parent.type) {
    case "ConditionalExpression":
    case "IfStatement":
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
      return parent.test === node;
    case "LogicalExpression":
      return isHandledLogicalOperator(parent.operator);
    case "AssignmentExpression":
      return isLogicalAssignmentOperator(parent.operator);
    default:
      return false;
  }
}
/**
 * Gets the boolean value of a given literal node.
 *
 * This is used to detect infinity loops (e.g. `while (true) {}`).
 * Statements preceded by an infinity loop are unreachable if the loop didn't
 * have any `break` statement.
 * @param {ASTNode} node A node to get.
 * @returns {boolean|undefined} a boolean value if the node is a Literal node,
 *   otherwise `undefined`.
 */
function getBooleanValueIfSimpleConstant(node) {
  if (node.type === "Literal") return Boolean(node.value);
}
/**
 * Checks that a given identifier node is a reference or not.
 *
 * This is used to detect the first throwable node in a `try` block.
 * @param {ASTNode} node An Identifier node to check.
 * @returns {boolean} `true` if the node is a reference.
 */
function isIdentifierReference(node) {
  const parent = node.parent;
  switch (parent.type) {
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ArrayPattern":
    case "RestElement":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "CatchClause":
      return false;
    case "FunctionDeclaration":
    case "ComponentDeclaration":
    case "HookDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassDeclaration":
    case "ClassExpression":
    case "VariableDeclarator":
      return parent.id !== node;
    case "Property":
    case "PropertyDefinition":
    case "MethodDefinition":
      return parent.key !== node || parent.computed || parent.shorthand;
    case "AssignmentPattern":
      return parent.key !== node;
    default:
      return true;
  }
}
/**
 * Updates the current segment with the head segment.
 * This is similar to local branches and tracking branches of git.
 *
 * To separate the current and the head is in order to not make useless segments.
 *
 * In this process, both "onCodePathSegmentStart" and "onCodePathSegmentEnd"
 * events are fired.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function forwardCurrentToHead(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  const currentSegments = state.currentSegments;
  const headSegments = state.headSegments;
  const end = Math.max(currentSegments.length, headSegments.length);
  let i, currentSegment, headSegment;
  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];
    if (currentSegment !== headSegment && currentSegment) {
      if (currentSegment.reachable) analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
    }
  }
  state.currentSegments = headSegments;
  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];
    if (currentSegment !== headSegment && headSegment) {
      CodePathSegment.markUsed(headSegment);
      if (headSegment.reachable) analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
    }
  }
}
/**
 * Updates the current segment with empty.
 * This is called at the last of functions or the program.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function leaveFromCurrentSegment(analyzer, node) {
  const state = CodePath.getState(analyzer.codePath);
  const currentSegments = state.currentSegments;
  for (let i = 0; i < currentSegments.length; ++i) {
    const currentSegment = currentSegments[i];
    if (currentSegment.reachable) analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
  }
  state.currentSegments = [];
}
/**
 * Updates the code path due to the position of a given node in the parent node
 * thereof.
 *
 * For example, if the node is `parent.consequent`, this creates a fork from the
 * current path.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function preprocess(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  const parent = node.parent;
  switch (parent.type) {
    case "CallExpression":
      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {
        state.makeOptionalRight();
      }
      break;
    case "MemberExpression":
      if (parent.optional === true && parent.property === node) state.makeOptionalRight();
      break;
    case "LogicalExpression":
      if (parent.right === node && isHandledLogicalOperator(parent.operator)) state.makeLogicalRight();
      break;
    case "AssignmentExpression":
      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) state.makeLogicalRight();
      break;
    case "ConditionalExpression":
    case "IfStatement":
      if (parent.consequent === node) state.makeIfConsequent();
      else if (parent.alternate === node) state.makeIfAlternate();
      break;
    case "SwitchCase":
      if (parent.consequent[0] === node) state.makeSwitchCaseBody(false, !parent.test);
      break;
    case "TryStatement":
      if (parent.handler === node) state.makeCatchBlock();
      else if (parent.finalizer === node) state.makeFinallyBlock();
      break;
    case "WhileStatement":
      if (parent.test === node) state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
      else {
        assert(parent.body === node);
        state.makeWhileBody();
      }
      break;
    case "DoWhileStatement":
      if (parent.body === node) state.makeDoWhileBody();
      else {
        assert(parent.test === node);
        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
      }
      break;
    case "ForStatement":
      if (parent.test === node) state.makeForTest(getBooleanValueIfSimpleConstant(node));
      else if (parent.update === node) state.makeForUpdate();
      else if (parent.body === node) state.makeForBody();
      break;
    case "ForInStatement":
    case "ForOfStatement":
      if (parent.left === node) state.makeForInOfLeft();
      else if (parent.right === node) state.makeForInOfRight();
      else {
        assert(parent.body === node);
        state.makeForInOfBody();
      }
      break;
    case "AssignmentPattern":
      if (parent.right === node) {
        state.pushForkContext();
        state.forkBypassPath();
        state.forkPath();
      }
      break;
    default:
      break;
  }
}
/**
 * Updates the code path due to the type of a given node in entering.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function processCodePathToEnter(analyzer, node) {
  let codePath = analyzer.codePath;
  let state = codePath && CodePath.getState(codePath);
  const parent = node.parent;
  /**
   * Creates a new code path and trigger the onCodePathStart event
   * based on the currently selected node.
   * @param {string} origin The reason the code path was started.
   * @returns {void}
   */
  function startCodePath(origin) {
    if (codePath) forwardCurrentToHead(analyzer, node);
    codePath = analyzer.codePath = new CodePath({
      id: analyzer.idGenerator.next(),
      origin,
      upper: codePath,
      onLooped: analyzer.onLooped,
    });
    state = CodePath.getState(codePath);
    analyzer.emitter.emit("onCodePathStart", codePath, node);
  }
  if (isPropertyDefinitionValue(node)) startCodePath("class-field-initializer");
  switch (node.type) {
    case "Program":
      startCodePath("program");
      break;
    case "FunctionDeclaration":
    case "ComponentDeclaration":
    case "HookDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      startCodePath("function");
      break;
    case "StaticBlock":
      startCodePath("class-static-block");
      break;
    case "ChainExpression":
      state.pushChainContext();
      break;
    case "CallExpression":
      if (node.optional === true) state.makeOptionalNode();
      break;
    case "MemberExpression":
      if (node.optional === true) state.makeOptionalNode();
      break;
    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
      break;
    case "AssignmentExpression":
      if (isLogicalAssignmentOperator(node.operator)) {
        state.pushChoiceContext(node.operator.slice(0, -1), isForkingByTrueOrFalse(node));
      }
      break;
    case "ConditionalExpression":
    case "IfStatement":
      state.pushChoiceContext("test", false);
      break;
    case "SwitchStatement":
      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));
      break;
    case "TryStatement":
      state.pushTryContext(Boolean(node.finalizer));
      break;
    case "SwitchCase":
      if (parent.discriminant !== node && parent.cases[0] !== node) state.forkPath();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.pushLoopContext(node.type, getLabel(node));
      break;
    case "LabeledStatement":
      if (!breakableTypePattern.test(node.body.type)) state.pushBreakContext(false, node.label.name);
      break;
    default:
      break;
  }
  forwardCurrentToHead(analyzer, node);
}
/**
 * Updates the code path due to the type of a given node in leaving.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function processCodePathToExit(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  let dontForward = false;
  switch (node.type) {
    case "ChainExpression":
      state.popChainContext();
      break;
    case "IfStatement":
    case "ConditionalExpression":
      state.popChoiceContext();
      break;
    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) state.popChoiceContext();
      break;
    case "AssignmentExpression":
      if (isLogicalAssignmentOperator(node.operator)) state.popChoiceContext();
      break;
    case "SwitchStatement":
      state.popSwitchContext();
      break;
    case "SwitchCase":
      if (node.consequent.length === 0) state.makeSwitchCaseBody(true, !node.test);
      if (state.forkContext.reachable) dontForward = true;
      break;
    case "TryStatement":
      state.popTryContext();
      break;
    case "BreakStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeBreak(node.label && node.label.name);
      dontForward = true;
      break;
    case "ContinueStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeContinue(node.label && node.label.name);
      dontForward = true;
      break;
    case "ReturnStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeReturn();
      dontForward = true;
      break;
    case "ThrowStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeThrow();
      dontForward = true;
      break;
    case "Identifier":
      if (isIdentifierReference(node)) {
        state.makeFirstThrowablePathInTryBlock();
        dontForward = true;
      }
      break;
    case "CallExpression":
    case "ImportExpression":
    case "MemberExpression":
    case "NewExpression":
    case "YieldExpression":
      state.makeFirstThrowablePathInTryBlock();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.popLoopContext();
      break;
    case "AssignmentPattern":
      state.popForkContext();
      break;
    case "LabeledStatement":
      if (!breakableTypePattern.test(node.body.type)) state.popBreakContext();
      break;
    default:
      break;
  }
  if (!dontForward) forwardCurrentToHead(analyzer, node);
}
/**
 * Updates the code path to finalize the current code path.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function postprocess(analyzer, node) {
  /**
   * Ends the code path for the current node.
   * @returns {void}
   */
  function endCodePath() {
    let codePath = analyzer.codePath;
    CodePath.getState(codePath).makeFinal();
    leaveFromCurrentSegment(analyzer, node);
    analyzer.emitter.emit("onCodePathEnd", codePath, node);
    codePath = analyzer.codePath = analyzer.codePath.upper;
  }
  switch (node.type) {
    case "Program":
    case "FunctionDeclaration":
    case "ComponentDeclaration":
    case "HookDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "StaticBlock":
      endCodePath();
      break;
    case "CallExpression":
      if (node.optional === true && node.arguments.length === 0) {
        CodePath.getState(analyzer.codePath).makeOptionalRight();
      }
      break;
    default:
      break;
  }
  if (isPropertyDefinitionValue(node)) endCodePath();
}
/**
 * The class to analyze code paths.
 * This class implements the EventGenerator interface.
 */
var CodePathAnalyzer = class {
  /**
   * @param {EventGenerator} eventGenerator An event generator to wrap.
   */
  constructor(emitters) {
    this.emitter = {
      emit(event, ...args) {
        emitters[event]?.(...args);
      },
    };
    this.codePath = null;
    this.idGenerator = new IdGenerator("s");
    this.currentNode = null;
    this.onLooped = this.onLooped.bind(this);
  }
  /**
   * Does the process to enter a given AST node.
   * This updates state of analysis and calls `enterNode` of the wrapped.
   * @param {ASTNode} node A node which is entering.
   * @returns {void}
   */
  enterNode(node) {
    this.currentNode = node;
    if (node.parent) preprocess(this, node);
    processCodePathToEnter(this, node);
    this.currentNode = null;
  }
  /**
   * Does the process to leave a given AST node.
   * This updates state of analysis and calls `leaveNode` of the wrapped.
   * @param {ASTNode} node A node which is leaving.
   * @returns {void}
   */
  leaveNode(node) {
    this.currentNode = node;
    processCodePathToExit(this, node);
    postprocess(this, node);
    this.currentNode = null;
  }
  /**
   * This is called on a code path looped.
   * Then this raises a looped event.
   * @param {CodePathSegment} fromSegment A segment of prev.
   * @param {CodePathSegment} toSegment A segment of next.
   * @returns {void}
   */
  onLooped(fromSegment, toSegment) {
    if (fromSegment.reachable && toSegment.reachable) {
      this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
    }
  }
};

// #endregion
