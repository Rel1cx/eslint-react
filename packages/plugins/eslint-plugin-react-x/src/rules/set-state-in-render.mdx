---
title: set-state-in-render
---

<Callout type="warning">
  This rule is currently in beta and only available in v3.0.0 beta releases.
</Callout>

**Full Name in [`@eslint-react/eslint-plugin@beta`](https://npmx.dev/package/@eslint-react/eslint-plugin/v/beta)**

```plain copy
@eslint-react/set-state-in-render
```

**Full Name in [`eslint-plugin-react-x@beta`](https://npmx.dev/package/eslint-plugin-react-x/v/beta)**

```plain copy
react-x/set-state-in-render
```

**Features**

`ğŸ§ª`

**Presets**

`x`
`recommended`
`recommended-typescript`
`recommended-type-checked`
`strict`
`strict-typescript`
`strict-type-checked`

## Description

Validates against unconditionally setting state during render, which can trigger additional renders and potential infinite render loops.

Calling `setState` during render unconditionally triggers another render before the current one finishes. This creates an infinite loop that crashes your app.

## Common Violations

### Invalid

```tsx
// âŒ Unconditional setState directly in render
function Component({ value }) {
  const [count, setCount] = useState(0);
  setCount(value); // Infinite loop!
  return <div>{count}</div>;
}
```

### Valid

```tsx
// âœ… Derive during render
function Component({ items }) {
  const sorted = [...items].sort(); // Just calculate it in render
  return <ul>{sorted.map(/*...*/)}</ul>;
}
```

```tsx
// âœ… Set state in event handler
function Component() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

```tsx
// âœ… Derive from props instead of setting state
function Component({ user }) {
  const name = user?.name || '';
  const email = user?.email || '';
  return <div>{name}</div>;
}
```

```tsx
// âœ… Conditionally derive state from props and state from previous renders
function Component({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) { // This condition makes it valid
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

## Troubleshooting

### I want to sync state to a prop

A common problem is trying to "fix" state after it renders. Suppose you want to keep a counter from exceeding a `max` prop:

```tsx
// âŒ Wrong: clamps during render
function Counter({ max }) {
  const [count, setCount] = useState(0);

  if (count > max) {
    setCount(max);
  }

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

As soon as `count` exceeds `max`, an infinite loop is triggered.

Instead, it's often better to move this logic to the event (the place where the state is first set). For example, you can enforce the maximum at the moment you update state:

```tsx
// âœ… Clamp when updating
function Counter({ max }) {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(current => Math.min(current + 1, max));
  };

  return <button onClick={increment}>{count}</button>;
}
```

Now the setter only runs in response to the click, React finishes the render normally, and `count` never crosses `max`.

In rare cases, you may need to adjust state based on information from previous renders. For those, follow the pattern of [setting state conditionally](https://react.dev/reference/react/useState#storing-information-from-previous-renders).

## Examples

### Failing

```tsx
import { useState } from "react";

function Component({ value }) {
  const [count, setCount] = useState(0);
  // ğŸ”´ Unconditional setState directly in render
  setCount(value);
  return <div>{count}</div>;
}
```

### Passing

```tsx
import { useState } from "react";

function Component() {
  const [count, setCount] = useState(0);
  // âœ… Set state in event handler
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

### Passing

```tsx
import { useState } from "react";

function Counter({ max }) {
  const [count, setCount] = useState(0);
  // âœ… Clamp when updating
  const increment = () => {
    setCount(current => Math.min(current + 1, max));
  };
  return <button onClick={increment}>{count}</button>;
}
```

### Passing

```tsx
import { useState } from "react";

function Component({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // âœ… Conditionally derive state from props and state from previous renders
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

## Implementation

- [Rule Source](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x/src/rules/set-state-in-render.ts)
- [Test Source](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x/src/rules/set-state-in-render.spec.ts)

## Further Reading

- [React Docs: `useState` Hook](https://react.dev/reference/react/useState)
- [React Docs: `set-state-in-render` Lint Rule](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render)

---

## See Also

- [`set-state-in-effect`](./set-state-in-effect)\
  Validates against setting state synchronously in an effect, which can lead to re-renders that degrade performance.
